// Generated by CoffeeScript 1.6.3
var CoffeeScript, buildTrueObj, defaultOptions, errorsToSkip, formatErrors, fs, hint, hintFiles, jshint, removeComments, splitArgs, _;

fs = require('fs');

CoffeeScript = require('coffee-script');

_ = require('underscore');

jshint = require('jshint').JSHINT;

defaultOptions = ['undef', 'eqnull', 'expr', 'shadow', 'sub', 'multistr'];

errorsToSkip = ["Did you mean to return a conditional instead of an assignment?", "Confusing use of '!'.", "Wrap the /regexp/ literal in parens to disambiguate the slash operator.", "Creating global 'for' variable. Should be 'for (var", "Missing '()' invoking a constructor."];

hintFiles = function(paths, config, log) {
  var data, globals, jsonData, options, splittedOptions;
  if (config.jshintrc) {
    data = fs.readFileSync(config.jshintrc, {
      encoding: "utf8"
    });
    jsonData = JSON.parse(removeComments(data));
    if (jsonData.globals) {
      globals = jsonData.globals;
      delete jsonData.globals;
    }
    options = jsonData;
  } else {
    globals = splitArgs(config.globals);
    splittedOptions = splitArgs(config.options);
    options = buildTrueObj(!config['default-options-off'] ? _.union(splittedOptions, defaultOptions) : splittedOptions);
  }
  return _.map(paths, function(path) {
    var err, errors, source;
    try {
      source = fs.readFileSync(path);
    } catch (_error) {
      err = _error;
      if (config.verbose) {
        console.log("Error reading " + path);
      }
      return [];
    }
    errors = hint(source, options, buildTrueObj(globals));
    if (log && errors.length > 0) {
      console.log("--------------------------------");
      console.log(formatErrors(path, errors));
    }
    return errors;
  });
};

hint = function(coffeeSource, options, globals) {
  var csOptions, js, sourceMap, v3SourceMap, _ref;
  csOptions = {
    sourceMap: true,
    filename: "doesn't matter"
  };
  _ref = CoffeeScript.compile(coffeeSource.toString(), csOptions), js = _ref.js, v3SourceMap = _ref.v3SourceMap, sourceMap = _ref.sourceMap;
  if (jshint(js, options, globals)) {
    return [];
  } else if (jshint.errors == null) {
    console.log("jshint didn't pass but returned no errors");
    return [];
  } else {
    return _.chain(jshint.errors).compact().map(function(error) {
      var col, line, _ref1;
      try {
        _ref1 = sourceMap.sourceLocation([error.line - 1, error.character - 1]), line = _ref1[0], col = _ref1[1];
      } catch (_error) {}
      return _.extend(error, {
        line: line != null ? line + 1 : '?',
        character: col != null ? col + 1 : '?'
      });
    }).filter(function(error) {
      return !_.any(errorsToSkip, function(to_skip) {
        return error.reason.indexOf(to_skip) >= 0;
      });
    }).value();
  }
};

formatErrors = function(path, errors) {
  return ("" + path + "\n") + _(errors).map(function(error) {
    return "" + error.line + ":" + error.character + ": " + error.reason;
  }).join('\n');
};

buildTrueObj = function(keys) {
  var i;
  return _.object(keys, (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = keys.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(true);
    }
    return _results;
  })());
};

removeComments = function(str) {
  if (str == null) {
    str = "";
  }
  str = str.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\//g, "");
  str = str.replace(/\/\/[^\n\r]*/g, "");
  return str;
};

splitArgs = function(strList) {
  var _ref;
  return (_ref = strList != null ? strList.split(',') : void 0) != null ? _ref : [];
};

module.exports = hintFiles;
